/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { Subscription, SubscriptionCollection, SubscriptionPreview, Transaction } from '../../entities';
import { type ErrorResponse, type Response } from '../../internal';
import { BaseResource, PathParameters, QueryParameters } from '../../internal/base';
import {
  type CancelSubscription,
  type CreateSubscriptionCharge,
  type GetSubscriptionQueryParameters,
  type ListSubscriptionQueryParameters,
  type PauseSubscription,
  type ResumeSubscription,
  type UpdateSubscriptionRequestBody,
} from './operations';
import { type ISubscriptionPreviewResponse, type ISubscriptionResponse, type ITransactionResponse } from '../../types';

const SubscriptionPaths = {
  get: '/subscriptions/{subscription_id}',
  update: '/subscriptions/{subscription_id}',
  updatePreview: '/subscriptions/{subscription_id}/preview',
  list: '/subscriptions',
  cancel: '/subscriptions/{subscription_id}/cancel',
  pause: '/subscriptions/{subscription_id}/pause',
  resume: '/subscriptions/{subscription_id}/resume',
  activate: '/subscriptions/{subscription_id}/activate',
  createOneTimeCharge: '/subscriptions/{subscription_id}/charge',
  previewOneTimeCharge: '/subscriptions/{subscription_id}/charge/preview',
  getTransactionToUpdatePaymentMethod: '/subscriptions/{subscription_id}/update-payment-method-transaction',
} as const;

export * from './operations';

export class SubscriptionsResource extends BaseResource {
  public async previewUpdate(
    subscriptionId: string,
    updateSubscription: UpdateSubscriptionRequestBody,
  ): Promise<SubscriptionPreview> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.updatePreview, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.patch<
      UpdateSubscriptionRequestBody,
      Response<ISubscriptionPreviewResponse> | ErrorResponse
    >(urlWithPathParams, updateSubscription);

    const data = this.handleResponse<ISubscriptionPreviewResponse>(response);

    return new SubscriptionPreview(data);
  }

  public async update(
    subscriptionId: string,
    updateSubscription: UpdateSubscriptionRequestBody,
  ): Promise<Subscription> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.update, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.patch<
      UpdateSubscriptionRequestBody,
      Response<ISubscriptionResponse> | ErrorResponse
    >(urlWithPathParams, updateSubscription);

    const data = this.handleResponse<ISubscriptionResponse>(response);

    return new Subscription(data);
  }

  public list(queryParams?: ListSubscriptionQueryParameters): SubscriptionCollection {
    const queryParameters = new QueryParameters(queryParams);
    return new SubscriptionCollection(this.client, SubscriptionPaths.list + queryParameters.toQueryString());
  }

  public async get(subscriptionId: string, queryParams?: GetSubscriptionQueryParameters): Promise<Subscription> {
    const queryParameters = new QueryParameters(queryParams);

    const urlWithPathParams = new PathParameters(SubscriptionPaths.get, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.get<
      GetSubscriptionQueryParameters | undefined,
      Response<ISubscriptionResponse> | ErrorResponse
    >(urlWithPathParams, queryParameters);

    const data = this.handleResponse<ISubscriptionResponse>(response);

    return new Subscription(data);
  }

  public async activate(subscriptionId: string): Promise<Subscription> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.activate, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.post<undefined, Response<ISubscriptionResponse> | ErrorResponse>(
      urlWithPathParams,
      undefined,
    );

    const data = this.handleResponse<ISubscriptionResponse>(response);

    return new Subscription(data);
  }

  public async pause(subscriptionId: string, requestBody: PauseSubscription): Promise<Subscription> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.pause, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.post<PauseSubscription, Response<ISubscriptionResponse> | ErrorResponse>(
      urlWithPathParams,
      requestBody,
    );

    const data = this.handleResponse<ISubscriptionResponse>(response);

    return new Subscription(data);
  }

  public async resume(subscriptionId: string, requestBody: ResumeSubscription): Promise<Subscription> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.resume, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.post<ResumeSubscription, Response<ISubscriptionResponse> | ErrorResponse>(
      urlWithPathParams,
      requestBody,
    );

    const data = this.handleResponse<ISubscriptionResponse>(response);

    return new Subscription(data);
  }

  public async cancel(subscriptionId: string, requestBody: CancelSubscription): Promise<Subscription> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.cancel, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.post<CancelSubscription, Response<ISubscriptionResponse> | ErrorResponse>(
      urlWithPathParams,
      requestBody,
    );

    const data = this.handleResponse<ISubscriptionResponse>(response);

    return new Subscription(data);
  }

  public async createOneTimeCharge(
    subscriptionId: string,
    requestBody: CreateSubscriptionCharge,
  ): Promise<Subscription> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.createOneTimeCharge, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.post<CreateSubscriptionCharge, Response<ISubscriptionResponse> | ErrorResponse>(
      urlWithPathParams,
      requestBody,
    );

    const data = this.handleResponse<ISubscriptionResponse>(response);

    return new Subscription(data);
  }

  public async previewOneTimeCharge(
    subscriptionId: string,
    requestBody: CreateSubscriptionCharge,
  ): Promise<SubscriptionPreview> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.previewOneTimeCharge, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.post<
      CreateSubscriptionCharge,
      Response<ISubscriptionPreviewResponse> | ErrorResponse
    >(urlWithPathParams, requestBody);

    const data = this.handleResponse<ISubscriptionPreviewResponse>(response);

    return new SubscriptionPreview(data);
  }

  public async getPaymentMethodChangeTransaction(subscriptionId: string): Promise<Transaction> {
    const urlWithPathParams = new PathParameters(SubscriptionPaths.getTransactionToUpdatePaymentMethod, {
      subscription_id: subscriptionId,
    }).deriveUrl();

    const response = await this.client.get<
      GetSubscriptionQueryParameters | undefined,
      Response<ITransactionResponse> | ErrorResponse
    >(urlWithPathParams);

    const data = this.handleResponse<ITransactionResponse>(response);

    return new Transaction(data);
  }
}
