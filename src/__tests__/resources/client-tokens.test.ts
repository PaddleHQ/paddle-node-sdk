/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  ClientTokenMockResponse,
  ClientTokensMock,
  ListClientTokenMockResponse,
} from '../mocks/resources/client-tokens.mock.js';
import {
  ClientTokensResource,
  CreateClientTokenRequestBody,
  ListClientTokenQueryParameters,
  UpdateClientTokenRequestBody,
} from '../../resources/client-tokens/index.js';

describe('ClientTokensResource', () => {
  test('should return a list of client-tokens', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListClientTokenMockResponse);

    const clientTokensResource = new ClientTokensResource(paddleInstance);
    const clientTokenCollection = clientTokensResource.list();

    let clientTokens = await clientTokenCollection.next();
    expect(paddleInstance.get).toHaveBeenCalledWith('/client-tokens?');
    expect(clientTokens.length).toBe(1);

    clientTokens = await clientTokenCollection.next();
    expect(paddleInstance.get).toHaveBeenCalledWith(
      'https://api.paddle.com/client-tokens?after=ctkn_01ghbkd0frb9k95cnhwd1bxpvk',
    );
    expect(clientTokens.length).toBe(1);
  });

  test('should accept query params and return a list of client-tokens', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListClientTokenMockResponse);
    const clientTokensResource = new ClientTokensResource(paddleInstance);
    const queryParams: ListClientTokenQueryParameters = {
      after: '2',
    };

    const clientTokenCollection = clientTokensResource.list(queryParams);
    const clientTokens = await clientTokenCollection.next();

    expect(paddleInstance.get).toHaveBeenCalledWith('/client-tokens?after=2');
    expect(clientTokens.length).toBe(1);
  });

  test('should return a single client-token by ID', async () => {
    const clientTokenId = ClientTokensMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ClientTokenMockResponse);

    const clientTokensResource = new ClientTokensResource(paddleInstance);
    const clientToken = await clientTokensResource.get(clientTokenId);

    expect(paddleInstance.get).toHaveBeenCalledWith(`/client-tokens/${clientTokenId}`);
    expect(clientToken).toBeDefined();
    expect(clientToken.id).toBe(clientTokenId);
  });

  test('should create a new client-token', async () => {
    const newClientToken: CreateClientTokenRequestBody = ClientTokensMock;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.post = jest.fn().mockResolvedValue(ClientTokenMockResponse);
    const clientTokensResource = new ClientTokensResource(paddleInstance);
    const clientToken = await clientTokensResource.create(newClientToken);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/client-tokens`, newClientToken);
    expect(clientToken).toBeDefined();
    expect(clientToken.id).toBeDefined();
    expect(clientToken.name).toBe(newClientToken.name);
  });

  test('should update an existing client-token', async () => {
    const clientTokenId = ClientTokensMock.id;
    const clientTokenRequestBody: UpdateClientTokenRequestBody = {
      status: 'active',
    };

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(ClientTokenMockResponse);

    const clientTokensResource = new ClientTokensResource(paddleInstance);
    const clientToken = await clientTokensResource.update(clientTokenId, clientTokenRequestBody);

    expect(paddleInstance.patch).toHaveBeenCalledWith(`/client-tokens/${clientTokenId}`, clientTokenRequestBody);
    expect(clientToken).toBeDefined();
  });

  test('should revoke an existing client-token', async () => {
    const clientTokenId = ClientTokensMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(ClientTokenMockResponse);

    const clientTokensResource = new ClientTokensResource(paddleInstance);
    const clientToken = await clientTokensResource.revoke(clientTokenId);

    expect(paddleInstance.patch).toHaveBeenCalledWith(`/client-tokens/${clientTokenId}`, { status: 'revoked' });
    expect(clientToken).toBeDefined();
  });
});
