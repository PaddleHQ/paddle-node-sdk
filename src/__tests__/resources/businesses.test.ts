/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  BusinessMock,
  BusinessMockResponse,
  ListBusinessMockResponse,
  UpdateBusinessExpectation,
  UpdateBusinessMock,
} from '../mocks/resources/businesses.mock.js';
import {
  BusinessesResource,
  CreateBusinessRequestBody,
  ListBusinessQueryParameters,
  UpdateBusinessRequestBody,
} from '../../resources/index.js';
import { convertToSnakeCase } from '../../internal/index.js';

describe('BusinessesResource', () => {
  test('should return a list of businesses', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListBusinessMockResponse);

    const businessesResource = new BusinessesResource(paddleInstance);
    const businessCollection = businessesResource.list('ctm_1234');

    let businesses = await businessCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/customers/ctm_1234/businesses?');
    expect(businesses.length).toBe(1);

    businesses = await businessCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/customers/ctm_1234/businesses?');
    expect(businesses.length).toBe(1);
  });

  test('should accept query params and return a list of businesses', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListBusinessMockResponse);
    const businessesResource = new BusinessesResource(paddleInstance);
    const queryParams: ListBusinessQueryParameters = {
      after: '2',
      id: ['1234'],
    };

    const businessCollection = businessesResource.list('ctm_1234', queryParams);
    const businesses = await businessCollection.next();

    expect(paddleInstance.get).toBeCalledWith('/customers/ctm_1234/businesses?after=2&id=1234');
    expect(businesses.length).toBe(1);
  });

  test('should return a single business by ID', async () => {
    const businessId = BusinessMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(BusinessMockResponse);

    const businessesResource = new BusinessesResource(paddleInstance);
    const business = await businessesResource.get('ctm_1234', businessId);

    expect(paddleInstance.get).toBeCalledWith(`/customers/ctm_1234/businesses/${businessId}`);
    expect(business).toBeDefined();
    expect(business.id).toBe(businessId);
  });

  test('should accepts query params and return a single business by ID', async () => {
    const businessId = BusinessMock.id;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.get = jest.fn().mockResolvedValue(BusinessMockResponse);
    const businessesResource = new BusinessesResource(paddleInstance);

    const business = await businessesResource.get('ctm_1234', businessId);

    expect(business).toBeDefined();
    expect(paddleInstance.get).toBeCalledWith(`/customers/ctm_1234/businesses/${businessId}`);
    expect(business.id).toBe(businessId);
  });

  test('should create a new business', async () => {
    const newBusiness: CreateBusinessRequestBody = BusinessMock;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.post = jest.fn().mockResolvedValue(BusinessMockResponse);
    const businessesResource = new BusinessesResource(paddleInstance);
    const createdBusiness = await businessesResource.create('ctm_1234', newBusiness);

    expect(paddleInstance.post).toBeCalledWith(`/customers/ctm_1234/businesses`, newBusiness);
    expect(createdBusiness).toBeDefined();
    expect(createdBusiness.id).toBeDefined();
    expect(createdBusiness.name).toBe(newBusiness.name);
  });

  test('should update an existing business', async () => {
    const businessId = BusinessMock.id;
    const businessToBeUpdated: UpdateBusinessRequestBody = {
      name: 'Updated Business',
    };

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(BusinessMockResponse);

    const businessesResource = new BusinessesResource(paddleInstance);
    const updatedBusiness = await businessesResource.update('ctm_1234', businessId, businessToBeUpdated);

    expect(paddleInstance.patch).toBeCalledWith(`/customers/ctm_1234/businesses/${businessId}`, businessToBeUpdated);
    expect(updatedBusiness).toBeDefined();

    expect(convertToSnakeCase(UpdateBusinessMock)).toEqual(UpdateBusinessExpectation);
  });

  test('should archive an existing business', async () => {
    const businessId = BusinessMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(BusinessMockResponse);

    const businessesResource = new BusinessesResource(paddleInstance);
    const updatedBusiness = await businessesResource.archive('ctm_1234', businessId);

    expect(paddleInstance.patch).toBeCalledWith(`/customers/ctm_1234/businesses/${businessId}`, { status: 'archived' });
    expect(updatedBusiness).toBeDefined();
  });
});
