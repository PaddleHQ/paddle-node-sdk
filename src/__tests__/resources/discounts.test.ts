/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  CreateDiscountExpectation,
  CreateDiscountMock,
  DiscountMock,
  DiscountMockResponse,
  ListDiscountMockResponse,
  UpdateDiscountExpectation,
  UpdateDiscountMock,
} from '../mocks/resources/discounts.mock.js';
import { CreateDiscountRequestBody, DiscountsResource, ListDiscountQueryParameters } from '../../resources/index.js';
import { convertToSnakeCase } from '../../internal/index.js';

describe('DiscountsResource', () => {
  test('should return a list of discounts', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListDiscountMockResponse);

    const discountsResource = new DiscountsResource(paddleInstance);
    const discountCollection = discountsResource.list();

    let discounts = await discountCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/discounts?');
    expect(discounts.length).toBe(1);

    discounts = await discountCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/discounts?after=1');
    expect(discounts.length).toBe(1);
  });

  test('should accept query params and return a list of discounts', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListDiscountMockResponse);
    const discountsResource = new DiscountsResource(paddleInstance);
    const queryParams: ListDiscountQueryParameters = {
      after: '2',
      id: ['1234'],
    };

    const discountCollection = discountsResource.list(queryParams);
    const discounts = await discountCollection.next();

    expect(paddleInstance.get).toBeCalledWith('/discounts?after=2&id=1234');
    expect(discounts.length).toBe(1);
  });

  test('should return a single discount by ID', async () => {
    const discountId = DiscountMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(DiscountMockResponse);

    const discountsResource = new DiscountsResource(paddleInstance);
    const discount = await discountsResource.get(discountId);

    expect(paddleInstance.get).toBeCalledWith(`/discounts/${discountId}`);
    expect(discount).toBeDefined();
    expect(discount.id).toBe(discountId);
  });

  test('should accepts query params and return a single discount by ID', async () => {
    const discountId = DiscountMock.id;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.get = jest.fn().mockResolvedValue(DiscountMockResponse);
    const discountsResource = new DiscountsResource(paddleInstance);

    const discount = await discountsResource.get(discountId);

    expect(discount).toBeDefined();
    expect(paddleInstance.get).toBeCalledWith(`/discounts/${discountId}`);
    expect(discount.id).toBe(discountId);
  });

  test('should create a new discount', async () => {
    const newDiscount: CreateDiscountRequestBody = DiscountMock;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.post = jest.fn().mockResolvedValue(DiscountMockResponse);
    const discountsResource = new DiscountsResource(paddleInstance);
    const createdDiscount = await discountsResource.create(newDiscount);

    expect(paddleInstance.post).toBeCalledWith(`/discounts`, newDiscount);
    expect(createdDiscount).toBeDefined();
    expect(createdDiscount.id).toBeDefined();

    expect(convertToSnakeCase(CreateDiscountMock)).toEqual(CreateDiscountExpectation);
  });

  test('should update an existing discount', async () => {
    const discountId = DiscountMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(DiscountMockResponse);

    const discountsResource = new DiscountsResource(paddleInstance);
    const updatedDiscount = await discountsResource.update(discountId, UpdateDiscountMock);

    expect(paddleInstance.patch).toBeCalledWith(`/discounts/${discountId}`, UpdateDiscountMock);
    expect(updatedDiscount).toBeDefined();

    expect(convertToSnakeCase(UpdateDiscountMock)).toEqual(UpdateDiscountExpectation);
  });

  test('should archive an existing discount', async () => {
    const discountId = DiscountMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(DiscountMockResponse);

    const discountsResource = new DiscountsResource(paddleInstance);
    const updatedDiscount = await discountsResource.archive(discountId);

    expect(paddleInstance.patch).toBeCalledWith(`/discounts/${discountId}`, { status: 'archived' });
    expect(updatedDiscount).toBeDefined();

    expect(convertToSnakeCase(UpdateDiscountMock)).toEqual(UpdateDiscountExpectation);
  });
});
