/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  CreatePriceExpectation,
  CreatePriceMock,
  ListPriceMockResponse,
  PriceMock,
  PriceMockResponse,
  UpdatePriceExpectation,
  UpdatePriceMock,
} from '../mocks/resources/prices.mock.js';
import { ListPriceQueryParameters, PricesResource } from '../../resources/index.js';
import { convertToSnakeCase } from '../../internal/index.js';

describe('PricesResource', () => {
  test('should return a list of prices', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListPriceMockResponse);

    const pricesResource = new PricesResource(paddleInstance);
    const priceCollection = pricesResource.list();

    let prices = await priceCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/prices?');
    expect(prices.length).toBe(1);

    prices = await priceCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/prices?after=1');
    expect(prices.length).toBe(1);
  });

  test('should accept query params and return a list of prices', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListPriceMockResponse);
    const pricesResource = new PricesResource(paddleInstance);
    const queryParams: ListPriceQueryParameters = {
      after: '2',
      id: ['1234'],
    };

    const priceCollection = pricesResource.list(queryParams);
    const prices = await priceCollection.next();

    expect(paddleInstance.get).toBeCalledWith('/prices?after=2&id=1234');
    expect(prices.length).toBe(1);
  });

  test('should return a single price by ID', async () => {
    const priceId = PriceMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(PriceMockResponse);

    const pricesResource = new PricesResource(paddleInstance);
    const price = await pricesResource.get(priceId);

    expect(paddleInstance.get).toBeCalledWith(`/prices/${priceId}`, { queryParams: undefined });
    expect(price).toBeDefined();
    expect(price.id).toBe(priceId);
  });

  test('should accepts query params and return a single price by ID', async () => {
    const priceId = PriceMock.id;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.get = jest.fn().mockResolvedValue(PriceMockResponse);
    const pricesResource = new PricesResource(paddleInstance);

    const price = await pricesResource.get(priceId);

    expect(price).toBeDefined();
    expect(paddleInstance.get).toBeCalledWith(`/prices/${priceId}`, { queryParameters: undefined });
    expect(price.id).toBe(priceId);
  });

  test('should create a new price', async () => {
    const newPrice = CreatePriceMock;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.post = jest.fn().mockResolvedValue(PriceMockResponse);
    const pricesResource = new PricesResource(paddleInstance);
    const createdPrice = await pricesResource.create(newPrice);

    expect(paddleInstance.post).toBeCalledWith(`/prices`, newPrice);
    expect(createdPrice).toBeDefined();
    expect(createdPrice.id).toBeDefined();
    expect(convertToSnakeCase(CreatePriceMock)).toEqual(CreatePriceExpectation);
  });

  test('should update an existing price', async () => {
    const priceId = PriceMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(PriceMockResponse);

    const pricesResource = new PricesResource(paddleInstance);
    const updatedPrice = await pricesResource.update(priceId, UpdatePriceMock);

    expect(paddleInstance.patch).toBeCalledWith(`/prices/${priceId}`, UpdatePriceMock);
    expect(updatedPrice).toBeDefined();
    expect(convertToSnakeCase(UpdatePriceMock)).toEqual(UpdatePriceExpectation);
  });

  test('should archive an existing price', async () => {
    const priceId = PriceMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(PriceMockResponse);

    const pricesResource = new PricesResource(paddleInstance);
    const updatedPrice = await pricesResource.archive(priceId);

    expect(paddleInstance.patch).toBeCalledWith(`/prices/${priceId}`, { status: 'archived' });
    expect(updatedPrice).toBeDefined();
  });
});
