/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  ListNotificationLogsMockResponse,
  ListNotificationMockResponse,
  NotificationMock,
  NotificationMockResponse,
  NotificationReplayMockResponse,
} from '../mocks/resources/notifications.mock.js';
import { ListNotificationQueryParameters, NotificationsResource } from '../../resources/index.js';

describe('NotificationsResource', () => {
  test('should return a list of notifications', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListNotificationMockResponse);

    const notificationsResource = new NotificationsResource(paddleInstance);
    const notificationCollection = notificationsResource.list();

    let notifications = await notificationCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/notifications?');
    expect(notifications.length).toBe(1);

    notifications = await notificationCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/notifications?after=1');
    expect(notifications.length).toBe(1);
  });

  test('should accept query params and return a list of notifications', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListNotificationMockResponse);
    const notificationsResource = new NotificationsResource(paddleInstance);
    const queryParams: ListNotificationQueryParameters = {
      after: '2',
      notificationSettingId: ['ntfset_1234'],
    };

    const notificationCollection = notificationsResource.list(queryParams);
    const notifications = await notificationCollection.next();

    expect(paddleInstance.get).toBeCalledWith('/notifications?after=2&notification_setting_id=ntfset_1234');
    expect(notifications.length).toBe(1);
  });

  test('should return a single notification by ID', async () => {
    const notificationId = NotificationMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(NotificationMockResponse);

    const notificationsResource = new NotificationsResource(paddleInstance);
    const notification = await notificationsResource.get(notificationId);

    expect(paddleInstance.get).toBeCalledWith(`/notifications/${notificationId}`);
    expect(notification).toBeDefined();
    expect(notification.id).toBe(notificationId);
  });

  test('should be able to replay a notification by ID', async () => {
    const notificationId = NotificationMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(NotificationReplayMockResponse);

    const notificationsResource = new NotificationsResource(paddleInstance);
    const notification = await notificationsResource.replay(notificationId);

    expect(paddleInstance.post).toBeCalledWith(`/notifications/${notificationId}/replay`, undefined);
    expect(notification).toBeDefined();
  });

  test('should return logs for notifications', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListNotificationLogsMockResponse);

    const notificationsResource = new NotificationsResource(paddleInstance);
    const notificationCollection = notificationsResource.getLogs('ntf_1234');

    let notifications = await notificationCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/notifications/ntf_1234/logs?');
    expect(notifications.length).toBe(3);

    notifications = await notificationCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/notifications/ntf_1234/logs?after=1');
    expect(notifications.length).toBe(3);
  });
});
