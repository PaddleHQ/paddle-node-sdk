/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  CreateSubscriptionExpectation,
  CreateSubscriptionMock,
  ListSubscriptionMockResponse,
  SubscriptionMock,
  SubscriptionMockResponse,
  SubscriptionPreviewMockResponse,
  UpdateSubscriptionExpectation,
  UpdateSubscriptionMock,
} from '../mocks/resources/subscriptions.mock.js';
import {
  CancelSubscription,
  GetSubscriptionQueryParameters,
  ListSubscriptionQueryParameters,
  PauseSubscription,
  ResumeSubscription,
  SubscriptionsResource,
  UpdateSubscriptionRequestBody,
} from '../../resources/index.js';
import { QueryParameters } from '../../internal/base/index.js';
import { convertToSnakeCase } from '../../internal/index.js';
import { TransactionMockResponse } from '../mocks/resources/transactions.mock.js';

describe('SubscriptionsResource', () => {
  test('should return a list of subscriptions', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListSubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const subscriptionCollection = subscriptionsResource.list();

    let subscriptions = await subscriptionCollection.next();
    expect(paddleInstance.get).toHaveBeenCalledWith('/subscriptions?');
    expect(subscriptions.length).toBe(1);

    subscriptions = await subscriptionCollection.next();
    expect(paddleInstance.get).toHaveBeenCalledWith('/subscriptions?after=1');
    expect(subscriptions.length).toBe(1);
  });

  test('should accept query params and return a list of subscriptions', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListSubscriptionMockResponse);
    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const queryParams: ListSubscriptionQueryParameters = {
      after: '2',
      id: ['1234'],
    };

    const subscriptionCollection = subscriptionsResource.list(queryParams);
    const subscriptions = await subscriptionCollection.next();

    expect(paddleInstance.get).toHaveBeenCalledWith('/subscriptions?after=2&id=1234');
    expect(subscriptions.length).toBe(1);
  });

  test('should return a single subscription by ID', async () => {
    const subscriptionId = SubscriptionMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const subscription = await subscriptionsResource.get(subscriptionId);

    expect(paddleInstance.get).toHaveBeenCalledWith(`/subscriptions/${subscriptionId}`, { queryParams: undefined });
    expect(subscription).toBeDefined();
    expect(subscription.id).toBe(subscriptionId);
  });

  test('should accepts query params and return a single subscription by ID', async () => {
    const subscriptionId = SubscriptionMock.id;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.get = jest.fn().mockResolvedValue(SubscriptionMockResponse);
    const subscriptionsResource = new SubscriptionsResource(paddleInstance);

    const queryParams: GetSubscriptionQueryParameters = {
      include: ['recurring_transaction_details', 'next_transaction'],
    };
    const subscription = await subscriptionsResource.get(subscriptionId, queryParams);

    expect(subscription).toBeDefined();
    expect(paddleInstance.get).toHaveBeenCalledWith(
      `/subscriptions/${subscriptionId}`,
      new QueryParameters(queryParams),
    );
    expect(subscription.id).toBe(subscriptionId);
  });

  test('should update an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated: UpdateSubscriptionRequestBody = UpdateSubscriptionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const updatedSubscription = await subscriptionsResource.update(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.patch).toHaveBeenCalledWith(`/subscriptions/${subscriptionId}`, subscriptionToBeUpdated);
    expect(updatedSubscription).toBeDefined();
    expect(convertToSnakeCase(UpdateSubscriptionMock)).toEqual(UpdateSubscriptionExpectation);
  });

  test('should update an existing subscription with non-catalog price', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated: UpdateSubscriptionRequestBody = UpdateSubscriptionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const updatedSubscription = await subscriptionsResource.update(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.patch).toHaveBeenCalledWith(`/subscriptions/${subscriptionId}`, subscriptionToBeUpdated);
    expect(updatedSubscription).toBeDefined();
    expect(convertToSnakeCase(UpdateSubscriptionMock)).toEqual(UpdateSubscriptionExpectation);
  });

  test('should preview update an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated: UpdateSubscriptionRequestBody = UpdateSubscriptionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const updatedSubscription = await subscriptionsResource.previewUpdate(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.patch).toHaveBeenCalledWith(
      `/subscriptions/${subscriptionId}/preview`,
      subscriptionToBeUpdated,
    );
    expect(updatedSubscription).toBeDefined();
    expect(convertToSnakeCase(UpdateSubscriptionMock)).toEqual(UpdateSubscriptionExpectation);
  });

  test('should activate an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const updatedSubscription = await subscriptionsResource.activate(subscriptionId);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/subscriptions/${subscriptionId}/activate`, undefined);
    expect(updatedSubscription).toBeDefined();
  });

  test('should pause an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated: PauseSubscription = { effectiveFrom: 'next_billing_period' };

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const updatedSubscription = await subscriptionsResource.pause(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/subscriptions/${subscriptionId}/pause`, subscriptionToBeUpdated);
    expect(updatedSubscription).toBeDefined();
  });

  test('should resume an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated: ResumeSubscription = {
      effectiveFrom: 'next_billing_period',
      onResume: 'continue_existing_billing_period',
    };

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const updatedSubscription = await subscriptionsResource.resume(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.post).toHaveBeenCalledWith(
      `/subscriptions/${subscriptionId}/resume`,
      subscriptionToBeUpdated,
    );
    expect(updatedSubscription).toBeDefined();
  });

  test('should cancel an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated: CancelSubscription = { effectiveFrom: 'next_billing_period' };

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const updatedSubscription = await subscriptionsResource.cancel(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.post).toHaveBeenCalledWith(
      `/subscriptions/${subscriptionId}/cancel`,
      subscriptionToBeUpdated,
    );
    expect(updatedSubscription).toBeDefined();
  });

  test('should return a transaction to update payment method', async () => {
    const subscriptionId = SubscriptionMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(TransactionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const subscription = await subscriptionsResource.getPaymentMethodChangeTransaction(subscriptionId);

    expect(paddleInstance.get).toHaveBeenCalledWith(
      `/subscriptions/${subscriptionId}/update-payment-method-transaction`,
    );
    expect(subscription).toBeDefined();
  });

  test('should preview create an one off charge for an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated = CreateSubscriptionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(SubscriptionPreviewMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const subscription = await subscriptionsResource.previewOneTimeCharge(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.post).toHaveBeenCalledWith(
      `/subscriptions/${subscriptionId}/charge/preview`,
      subscriptionToBeUpdated,
    );
    expect(subscription).toBeDefined();
  });

  test('should create an one off charge for an existing subscription', async () => {
    const subscriptionId = SubscriptionMock.id;
    const subscriptionToBeUpdated = CreateSubscriptionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(SubscriptionMockResponse);

    const subscriptionsResource = new SubscriptionsResource(paddleInstance);
    const subscription = await subscriptionsResource.createOneTimeCharge(subscriptionId, subscriptionToBeUpdated);

    expect(paddleInstance.post).toHaveBeenCalledWith(
      `/subscriptions/${subscriptionId}/charge`,
      subscriptionToBeUpdated,
    );
    expect(subscription).toBeDefined();
    expect(convertToSnakeCase(CreateSubscriptionMock)).toEqual(CreateSubscriptionExpectation);
  });
});
