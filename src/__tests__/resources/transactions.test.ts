/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  CreateTransactionExpectation,
  CreateTransactionMock,
  ListTransactionMockResponse,
  PreviewTransactionMock,
  ReviseTransactionMock,
  TransactionMock,
  TransactionMockResponse,
  TransactionPreviewMockResponse,
  UpdateTransactionExpectation,
  UpdateTransactionMock,
} from '../mocks/resources/transactions.mock.js';
import {
  CreateTransactionRequestBody,
  GetTransactionQueryParameters,
  ListTransactionQueryParameters,
  ReviseTransactionRequestBody,
  TransactionsResource,
  UpdateTransactionRequestBody,
} from '../../resources/index.js';
import { QueryParameters } from '../../internal/base/index.js';
import { convertToSnakeCase } from '../../internal/index.js';

describe('TransactionsResource', () => {
  test('should return a list of transactions', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListTransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const transactionCollection = transactionsResource.list();

    let transactions = await transactionCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/transactions?');
    expect(transactions.length).toBe(1);

    transactions = await transactionCollection.next();
    expect(paddleInstance.get).toBeCalledWith('/transactions?after=1');
    expect(transactions.length).toBe(1);
  });

  test('should accept query params and return a list of transactions', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListTransactionMockResponse);
    const transactionsResource = new TransactionsResource(paddleInstance);
    const queryParams: ListTransactionQueryParameters = {
      after: '2',
      id: ['1234'],
      'createdAt[GTE]': '2024-09-10T15:38:35.675098Z',
    };

    const transactionCollection = transactionsResource.list(queryParams);
    const transactions = await transactionCollection.next();

    expect(paddleInstance.get).toBeCalledWith(
      '/transactions?after=2&id=1234&created_at%5BGTE%5D=2024-09-10T15%3A38%3A35.675098Z',
    );
    expect(transactions.length).toBe(1);
  });

  test('should return a single transaction by ID', async () => {
    const transactionId = TransactionMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const transaction = await transactionsResource.get(transactionId);

    expect(paddleInstance.get).toBeCalledWith(`/transactions/${transactionId}`, { queryParams: undefined });
    expect(transaction).toBeDefined();
    expect(transaction.id).toBe(transactionId);
  });

  test('should accepts query params and return a single transaction by ID', async () => {
    const transactionId = TransactionMock.id;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.get = jest.fn().mockResolvedValue(TransactionMockResponse);
    const transactionsResource = new TransactionsResource(paddleInstance);

    const queryParams: GetTransactionQueryParameters = {
      include: ['address', 'adjustment'],
    };
    const transaction = await transactionsResource.get(transactionId, queryParams);

    expect(transaction).toBeDefined();
    expect(paddleInstance.get).toBeCalledWith(`/transactions/${transactionId}`, new QueryParameters(queryParams));
    expect(transaction.id).toBe(transactionId);
  });

  test('should create a new transaction', async () => {
    const newTransaction: CreateTransactionRequestBody = CreateTransactionMock;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.post = jest.fn().mockResolvedValue(TransactionMockResponse);
    const transactionsResource = new TransactionsResource(paddleInstance);
    const createdTransaction = await transactionsResource.create(newTransaction);

    expect(paddleInstance.post).toBeCalledWith(`/transactions?`, newTransaction);
    expect(createdTransaction).toBeDefined();
    expect(createdTransaction.id).toBeDefined();
    expect(convertToSnakeCase(CreateTransactionMock)).toEqual(CreateTransactionExpectation);
  });

  test('should update an existing transaction', async () => {
    const transactionId = TransactionMock.id;
    const transactionToBeUpdated: UpdateTransactionRequestBody = UpdateTransactionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const updatedTransaction = await transactionsResource.update(transactionId, transactionToBeUpdated);

    expect(paddleInstance.patch).toBeCalledWith(`/transactions/${transactionId}?`, transactionToBeUpdated);
    expect(updatedTransaction).toBeDefined();
    expect(convertToSnakeCase(UpdateTransactionMock)).toEqual(UpdateTransactionExpectation);
  });

  test('should get an link to download invoice PDF for an existing transaction', async () => {
    const transactionId = TransactionMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const updatedTransaction = await transactionsResource.getInvoicePDF(transactionId);

    expect(paddleInstance.get).toBeCalledWith(`/transactions/${transactionId}/invoice?`);
    expect(updatedTransaction).toBeDefined();
  });

  test('should be able to preview a transaction', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(TransactionPreviewMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const updatedTransaction = await transactionsResource.preview(PreviewTransactionMock);

    expect(paddleInstance.post).toBeCalledWith(`/transactions/preview`, PreviewTransactionMock);
    expect(updatedTransaction).toBeDefined();
  });

  test('should be able to revise an existing transaction', async () => {
    const transactionId = TransactionMock.id;
    const transactionToBeRevised: ReviseTransactionRequestBody = ReviseTransactionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const revisedTransaction = await transactionsResource.revise(transactionId, transactionToBeRevised);

    expect(paddleInstance.post).toBeCalledWith(`/transactions/${transactionId}/revise`, transactionToBeRevised);
    expect(revisedTransaction).toBeDefined();
  });
});
