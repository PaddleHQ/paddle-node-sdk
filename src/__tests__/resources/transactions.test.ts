/**
 *  ! Autogenerated code !
 *  Do not make changes to this file.
 *  Changes may be overwritten as part of auto-generation.
 */

import { getPaddleTestClient } from '../helpers/test-client.js';
import {
  CreateTransactionExpectation,
  CreateTransactionMock,
  ListTransactionMockResponse,
  PreviewTransactionMock,
  ReviseTransactionMock,
  TransactionMock,
  TransactionMockResponse,
  TransactionPreviewMockResponse,
  UpdateTransactionExpectation,
  UpdateTransactionMock,
} from '../mocks/resources/transactions.mock.js';
import {
  CreateTransactionRequestBody,
  GetTransactionQueryParameters,
  ListTransactionQueryParameters,
  ReviseTransactionRequestBody,
  TransactionsResource,
  UpdateTransactionRequestBody,
  NonCatalogDiscount,
  TransactionPreviewRequestBody,
} from '../../resources/index.js';
import { QueryParameters } from '../../internal/base/index.js';
import { convertToSnakeCase } from '../../internal/index.js';

describe('TransactionsResource', () => {
  test('should return a list of transactions', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListTransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const transactionCollection = transactionsResource.list();

    let transactions = await transactionCollection.next();
    expect(paddleInstance.get).toHaveBeenCalledWith('/transactions?');
    expect(transactions.length).toBe(1);

    transactions = await transactionCollection.next();
    expect(paddleInstance.get).toHaveBeenCalledWith('/transactions?after=1');
    expect(transactions.length).toBe(1);
  });

  test('should accept query params and return a list of transactions', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(ListTransactionMockResponse);
    const transactionsResource = new TransactionsResource(paddleInstance);
    const queryParams: ListTransactionQueryParameters = {
      after: '2',
      id: ['1234'],
      'createdAt[GTE]': '2024-09-10T15:38:35.675098Z',
    };

    const transactionCollection = transactionsResource.list(queryParams);
    const transactions = await transactionCollection.next();

    expect(paddleInstance.get).toHaveBeenCalledWith(
      '/transactions?after=2&id=1234&created_at%5BGTE%5D=2024-09-10T15%3A38%3A35.675098Z',
    );
    expect(transactions.length).toBe(1);
  });

  test('should return a single transaction by ID', async () => {
    const transactionId = TransactionMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const transaction = await transactionsResource.get(transactionId);

    expect(paddleInstance.get).toHaveBeenCalledWith(`/transactions/${transactionId}`, { queryParams: undefined });
    expect(transaction).toBeDefined();
    expect(transaction.id).toBe(transactionId);
  });

  test('should accepts query params and return a single transaction by ID', async () => {
    const transactionId = TransactionMock.id;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.get = jest.fn().mockResolvedValue(TransactionMockResponse);
    const transactionsResource = new TransactionsResource(paddleInstance);

    const queryParams: GetTransactionQueryParameters = {
      include: ['address', 'adjustment'],
    };
    const transaction = await transactionsResource.get(transactionId, queryParams);

    expect(transaction).toBeDefined();
    expect(paddleInstance.get).toHaveBeenCalledWith(`/transactions/${transactionId}`, new QueryParameters(queryParams));
    expect(transaction.id).toBe(transactionId);
  });

  test('should create a new transaction', async () => {
    const newTransaction: CreateTransactionRequestBody = CreateTransactionMock;
    const paddleInstance = getPaddleTestClient();

    paddleInstance.post = jest.fn().mockResolvedValue(TransactionMockResponse);
    const transactionsResource = new TransactionsResource(paddleInstance);
    const createdTransaction = await transactionsResource.create(newTransaction);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/transactions?`, newTransaction);
    expect(createdTransaction).toBeDefined();
    expect(createdTransaction.id).toBeDefined();
    expect(convertToSnakeCase(CreateTransactionMock)).toEqual(CreateTransactionExpectation);
  });

  test('create includes NonCatalogDiscount with custom_data and restrict_to', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);

    const discount: NonCatalogDiscount = {
      amount: '250',
      description: 'NCD for create',
      type: 'flat',
      recur: false,
      maximumRecurringIntervals: null,
      customData: { internal_reference: 'create_ref' },
      restrictTo: ['pri_123'],
    };

    const body: CreateTransactionRequestBody = {
      ...CreateTransactionMock,
      discountId: null,
      discount,
    };

    await transactionsResource.create(body);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/transactions?`, body);
  });

  test('should update an existing transaction', async () => {
    const transactionId = TransactionMock.id;
    const transactionToBeUpdated: UpdateTransactionRequestBody = UpdateTransactionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const updatedTransaction = await transactionsResource.update(transactionId, transactionToBeUpdated);

    expect(paddleInstance.patch).toHaveBeenCalledWith(`/transactions/${transactionId}?`, transactionToBeUpdated);
    expect(updatedTransaction).toBeDefined();
    expect(convertToSnakeCase(UpdateTransactionMock)).toEqual(UpdateTransactionExpectation);
  });

  test('update includes NonCatalogDiscount with custom_data and restrict_to', async () => {
    const transactionId = TransactionMock.id;
    const paddleInstance = getPaddleTestClient();
    paddleInstance.patch = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);

    const discount: NonCatalogDiscount = {
      amount: '300',
      description: 'NCD for update',
      type: 'percentage',
      recur: true,
      maximumRecurringIntervals: 5,
      customData: { internal_reference: 'update_ref' },
      restrictTo: ['pri_456', 'pri_789'],
    };

    const body: UpdateTransactionRequestBody = {
      ...UpdateTransactionMock,
      discountId: null,
      discount,
    };

    await transactionsResource.update(transactionId, body);

    expect(paddleInstance.patch).toHaveBeenCalledWith(`/transactions/${transactionId}?`, body);
  });

  test('should get an link to download invoice PDF for an existing transaction', async () => {
    const transactionId = TransactionMock.id;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.get = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const updatedTransaction = await transactionsResource.getInvoicePDF(transactionId);

    expect(paddleInstance.get).toHaveBeenCalledWith(`/transactions/${transactionId}/invoice?`);
    expect(updatedTransaction).toBeDefined();
  });

  test('should be able to preview a transaction', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(TransactionPreviewMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const updatedTransaction = await transactionsResource.preview(PreviewTransactionMock);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/transactions/preview`, PreviewTransactionMock);
    expect(updatedTransaction).toBeDefined();
  });

  test('preview accepts NonCatalogDiscount with custom_data and restrict_to', async () => {
    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(TransactionPreviewMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);

    const discount: NonCatalogDiscount = {
      amount: '150',
      description: 'NCD for preview',
      type: 'flat',
      recur: false,
      maximumRecurringIntervals: null,
      customData: { internal_reference: 'preview_ref' },
      restrictTo: ['pri_123'],
    };

    const body: TransactionPreviewRequestBody = {
      ...PreviewTransactionMock,
      discount,
    };

    await transactionsResource.preview(body);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/transactions/preview`, body);
  });

  test('should be able to revise an existing transaction', async () => {
    const transactionId = TransactionMock.id;
    const transactionToBeRevised: ReviseTransactionRequestBody = ReviseTransactionMock;

    const paddleInstance = getPaddleTestClient();
    paddleInstance.post = jest.fn().mockResolvedValue(TransactionMockResponse);

    const transactionsResource = new TransactionsResource(paddleInstance);
    const revisedTransaction = await transactionsResource.revise(transactionId, transactionToBeRevised);

    expect(paddleInstance.post).toHaveBeenCalledWith(`/transactions/${transactionId}/revise`, transactionToBeRevised);
    expect(revisedTransaction).toBeDefined();
  });
});
